虚拟文件系统分为两部分，服务器端（开发环境）和客户端（手机环境）。

虚拟文件系统会将服务器端本地一个资源目录映射到客户端。客户端采用类似 git 仓库的储存方式，服务器端用一个索引目录缓存索引信息。

服务器索引部分：

和 git 不同，不需要在仓库管理多版本信息。文件分为两类：文件和目录。索引信息用 hash 值做索引。

客户端请求分为两步：用一个字符串路径请求这个对象（文件或目录）对应的 hash id ；用 hash id 向服务器请求具体文件。所以，在服务器的索引目录，我们需要以 hash id 为文件名，保存对应文件的索引信息。

例如，假设仓库是这样的：

/ a /
    + file1
  b /
  file2

那么对于根目录，需要保存这样的索引信息：

a dir hash
b dir hash
file2 file hash

对于 a b 子目录，只需要记录 hash 。

我们假定在手机 app 运行过程中，文件基本不会发生变化。如果有变，那么认为需要重启 app ，重建索引信息。时间戳同时可用来加速索引重建过程：时间戳不变时，可以不重算 hash 。

如果需要打开 /a/file1 文件，则需要先打开 / 根目录文件，然后找到 a 对应的 hash ，再从 hash 打开对应的 /a 文件，再找到 file2 条目。

对于文件，索引信息用 hash.ref 做其文件名，记录

realpath timestamp
realpath timestamp
...

注意，同一个 hash 可能对应多条路径，建立索引时应全部建立。打开 hash 对应的文件时，可只检查第一条记录。如果第一条记录匹配不上，即可请求重建索引。但，如果服务器客户端不一致时，如果要增加容错性，可以依次检查，找到合适的文件。例如，/a/file1 和 /file2 原本相同。后来 /a/file1 发生了改变。如果客户端请求 /file2 对应的 hash ，即使服务器未重建索引，也应该尝试打开 /file2 读取数据（因为 /file2 未变）

注：重建索引应该删除不再使用的 hash 索引信息，尤其是目录文件变更频繁。例如：任何一个文件变更，都会让根目录的 hash 发生变化。

索引目录下有一个 root 文件，保存有根目录的 hash 值，指向根对象。

对于客户端部分，仓库保存的是所有文件/目录对象的内容。

目录对象和服务器的目录索引完全相同，但文件对象是文件的具体内容。

例如，请求 /a/file1 ，可分别向服务器请求 / 对象 /a 对象 和 /a/file1 对象。

因为客户端通常有缓存，那么应该先一次查询 / 对象本地 hash 值对应服务器端对象的有效性。服务器会删除所有过期对象，一旦 / 对象有效，就可说明整个仓库均无修改。那么就可以直接从本地逐级解析，最终得到 /a/file1 对象的 hash 。如果 / 对象无效，则应向服务器索取最新的 root 对象的副本。之后，再从新的 root 对象中查询 /a 对象，此时，/a 对象很可能本地并无变化，后续就不再查询。

简述流程：

1. 启动时，先查询本地缓存的根对象是否有效。如果无效，请求最新版本的根对象。拿到最新版本的根对象后，从这里索引的所有文件 hash 都保证是正确的版本。

2. 分解路径，从本地 cache 依次索引最终文件对象的 hash 。无论在任何环节本地 cache 无效，都向服务器请求。

注意：客户端仓库不必删除过期的对象，而是用明确的指令主动清理。

目录文件的格式：

采用无 BOM 头的 UTF8 编码，回车使用 Unix 风格，只有 \n ，最后一行需要加 \n

一行一个文件，类型 sha1 文件名用空格分隔。sha1 采用小写的 hex 形式， timestamp 采用十进制数字，类型是 f 或 d 。文件名中不可以有空格。

范例：

f 90a5c279259fd4e105c4eb8378e9a21694e1e3c4 vfs.txt
