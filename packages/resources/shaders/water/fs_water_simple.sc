$input v_posCS v_distortUV v_noiseUV

#include <bgfx_shader.sh>

// Properties
// {
//     // What color the water will sample when the surface below is shallow.
//     u_DepthGradientShallow("Depth Gradient Shallow", Color) = (0.325, 0.807, 0.971, 0.725)

//     // What color the water will sample when the surface below is at its deepest.
//     u_DepthGradientDeep("Depth Gradient Deep", Color) = (0.086, 0.407, 1, 0.749)

//     // Maximum distance the surface below the water will affect the color gradient.
//     u_DepthMaxDistance("Depth Maximum Distance", Float) = 1

//     // Color to render the foam generated by objects intersecting the surface.
//     u_FoamColor("Foam Color", Color) = (1,1,1,1)

//     // Noise texture used to generate waves.
//     s_SurfaceNoise("Surface Noise", 2D) = "white" {}

//     // Speed, in UVs per second the noise will scroll. Only the xy components are used.
//     u_SurfaceNoiseScroll("Surface Noise Scroll Amount", Vector) = (0.03, 0.03, 0, 0)

//     // Values in the noise texture above this cutoff are rendered on the surface.
//     u_SurfaceNoiseCutoff("Surface Noise Cutoff", Range(0, 1)) = 0.777

//     // Red and green channels of this texture are used to offset the
//     // noise texture to create distortion in the waves.
//     s_SurfaceDistortion("Surface Distortion", 2D) = "white" {}	

//     // Multiplies the distortion by this value.
//     u_SurfaceDistortionAmount("Surface Distortion Amount", Range(0, 1)) = 0.27

//     // Control the distance that surfaces below the water will contribute
//     // to foam being rendered.
//     u_FoamMaxDistance("Foam Maximum Distance", Float) = 0.4
//     u_FoamMinDistance("Foam Minimum Distance", Float) = 0.04		
// }

#include "common/camera.sh"

SAMPLER2D(s_SurfaceNoise,       0);
SAMPLER2D(s_SurfaceDistortion,  1);
SAMPLER2D(s_scene_depth,        2);

uniform vec4 u_DepthGradientShallow;
uniform vec4 u_DepthGradientDeep;
uniform vec4 u_FoamColor;

uniform vec4 u_distance_param;
#define u_DepthMaxDistance   u_distance_param.x
#define u_FoamMinDistance    u_distance_param.y
#define u_FoamMaxDistance    u_distance_param.z

uniform vec4 u_surface_param;
#define u_SurfaceNoiseScroll         u_surface_param.xy
#define u_SurfaceNoiseCutoff         u_surface_param.z
#define u_SurfaceDistortionAmount    u_surface_param.w

#define SMOOTHSTEP_AA 0.01

// Blends two colors using the same algorithm that our shader is using
// to blend with the screen. This is usually called "normal blending",
// and is similar to how software like Photoshop blends two layers.
vec4 alphaBlend(vec4 top, vec4 bottom)
{
    vec3 color = (top.rgb * top.a) + (bottom.rgb * (1 - top.a));
    float alpha = top.a + bottom.a * (1 - top.a);

    return vec4(color, alpha);
}


void main()
{
    // Retrieve the current depth value of the surface behind the
    // pixel we are currently rendering.
    float existingDepth01 = texture2DProj(s_scene_depth, v_posCS).r;
    // Convert the depth from non-linear 0...1 range to linear
    // depth, in Unity units.
    float scene_depthVS = linear_depth(existingDepth01);

    // Difference, in Unity units, between the water's surface and the object behind it.
    float obj_depthVS = v_posCS.w;
    float depthDifference = scene_depthVS - obj_depthVS;

    // Calculate the color of the water based on the depth using our two gradient colors.
    float waterDepthDifference01 = saturate(depthDifference / u_DepthMaxDistance);
    vec4 waterColor = lerp(u_DepthGradientShallow, u_DepthGradientDeep, waterDepthDifference01);
    
    // Retrieve the view-space normal of the surface behind the
    // pixel we are currently rendering.
    vec3 existingNormal = texture2DProj(_CameraNormalsTexture, v_posCS);
    
    // Modulate the amount of foam we display based on the difference
    // between the normals of our water surface and the object behind it.
    // Larger differences allow for extra foam to attempt to keep the overall
    // amount consistent.
    //vec3 normalDot = saturate(dot(existingNormal, i.viewNormal));
    float foamDistance = u_FoamMaxDistance; //lerp(u_FoamMaxDistance, u_FoamMinDistance, 0.5);
    float foamDepthDifference01 = saturate(depthDifference / foamDistance);

    float surfaceNoiseCutoff = foamDepthDifference01 * u_SurfaceNoiseCutoff;

    vec2 distortSample = (texture2D(s_SurfaceDistortion, v_distortUV).xy * 2 - 1) * u_SurfaceDistortionAmount;

    // Distort the noise UV based off the RG channels (using xy here) of the distortion texture.
    // Also offset it by time, scaled by the scroll speed.
    // vec2 noiseUV = vec2((v_noiseUV.x + _Time.y * u_SurfaceNoiseScroll.x) + distortSample.x, 
    //                     (v_noiseUV.y + _Time.y * u_SurfaceNoiseScroll.y) + distortSample.y);
    vec2 noiseUV = v_noiseUV + u_current_time * u_SurfaceNoiseScroll + distortSample;
    float surfaceNoiseSample = texture2D(s_SurfaceNoise, noiseUV).r;

    // Use smoothstep to ensure we get some anti-aliasing in the transition from foam to surface.
    // Uncomment the line below to see how it looks without AA.
    // float surfaceNoise = surfaceNoiseSample > surfaceNoiseCutoff ? 1 : 0;
    float surfaceNoise = smoothstep(surfaceNoiseCutoff - SMOOTHSTEP_AA, surfaceNoiseCutoff + SMOOTHSTEP_AA, surfaceNoiseSample);

    vec4 surfaceNoiseColor = u_FoamColor;
    surfaceNoiseColor.a *= surfaceNoise;

    // Use normal alpha blending to combine the foam with the surface.
    gl_FragColor = alphaBlend(surfaceNoiseColor, waterColor);
}